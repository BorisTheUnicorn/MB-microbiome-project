---
title: "NM Microbiome - 02 Original Susceptibility Analysis"
author: "Orr Tobaly & Nikol Elyashov"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: united
    highlight: tango
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

## 1. Setup and Library Loading

```{r load-libraries}
# Load required packages
library(phyloseq)
library(ANCOMBC)
library(dplyr)
library(ggplot2)
library(tidyr)
library(readxl)
library(DT)
library(patchwork)
library(microbiome)
library(viridis)
library(ggpubr)

# Source custom functions
source("../R/preprocessing_functions.R")
source("../R/differential_abundance.r")
source("../R/visualization_functions.r")

# Set data paths
processed_data_dir <- "../data/processed_to_ANCOM/"
results_dir <- "../results/original_susceptibility/"

# Create results directory if it doesn't exist
if(!dir.exists(results_dir)) {
  dir.create(results_dir, recursive = TRUE)
}
```

## 2. Load Preprocessed Data

```{r load-data}
# Load the preprocessed phyloseq object
ps <- readRDS(file.path(processed_data_dir, "preprocessed_to_ANCOM_phyloseq.rds"))

# Check that our carriage classifications are present
print("Carriage group distribution:")
table(sample_data(ps)$carriage_group)

# Import demographic data for additional covariates
demographic_data <- read_excel("../data/raw/demographic data _Jan2022_final.YM.20241230.xlsx")

# Clean and prepare demographic data
demographic_data <- demographic_data %>%
  mutate(
    pid = as.character(pid),  # Ensure pid is character for joining
    boardingschool = factor(boardingschool),
    selfsmoking = factor(selfsmoking),
    secondsmoker = factor(secondsmoker),
    AB_month = factor(AB_month),  # Antibiotic use in previous month
    AB_year = factor(AB_year)     # Antibiotic use in previous year
  )

# Merge relevant demographic variables with sample data
# First, get the current sample data
sample_data_df <- data.frame(sample_data(ps))

# Ensure 'pid' is preserved as the identifier
sample_data_with_demo <- sample_data_df %>%
  left_join(demographic_data %>% 
              select(pid, boardingschool, selfsmoking, secondsmoker, 
                     AB_month, AB_year, yearofbirth, family_members), 
            by = "pid")

# Rebuild the sample_data ensuring original sample names are preserved
rownames(sample_data_with_demo) <- sample_data_df$SampleID

# Update the phyloseq object with new sample data
sample_data(ps) <- sample_data(sample_data_with_demo)

# Verify the update worked
print("Updated sample data columns:")
names(sample_data(ps))
```

## 3. Analysis Design and Data Subset Selection
For this susceptibility analysis, we will focus on baseline samples (time point 0) from individuals classified as "Acquisition_carrier" or "Non_carrier". This will allow us to investigate initial microbiome differences that might predispose individuals to acquiring NM.


```{r subset-selection}
# The 'ps' object is loaded and has demographic data merged from the previous chunk.

# Define ps_baseline: 
# Filters from 'ps': 
#   - time == "0" 
#   - carriage_group %in% c("Acquisition_carrier", "Non_carrier")
#   - batch != "4" (Batch 4 is excluded directly here)

ps_baseline <- subset_samples(ps, 
                                time == "0" & 
                                carriage_group %in% c("Acquisition_carrier", "Non_carrier") &
                                batch != "4")

# Check sample sizes for the new ps_baseline
print("Sample counts for ps_baseline (Time 0, Acquisition vs. Non-carriers, Batch 4 excluded):")
if (nsamples(ps_baseline) > 0) {
  print(table(sample_data(ps_baseline)$carriage_group, sample_data(ps_baseline)$batch, dnn=c("Carriage Group", "Batch")))
  print(paste("Total samples in ps_baseline:", nsamples(ps_baseline)))

  # Verify that we have adequate data for comparison within each carriage group (overall)
  if(min(table(sample_data(ps_baseline)$carriage_group)) < 10) {
    warning("Warning: One of the carriage groups in ps_baseline has fewer than 10 samples overall. Downstream results, especially group comparisons, may be unstable or have low power.")
  } else {
    print("Both carriage groups in ps_baseline have adequate overall sample sizes (≥10).")
  }
  
  # Further check: Ensure each batch within each carriage group has enough samples for faceted plots/stats
  count_table <- table(sample_data(ps_baseline)$carriage_group, sample_data(ps_baseline)$batch)
  if (any(count_table > 0 & count_table < 3)) { # Check for groups with 1 or 2 samples within batches
      warning("Some combinations of carriage_group and batch have very few samples (1 or 2). Faceted plots and within-batch statistical comparisons might be misleading or fail for these combinations.")
  }
  
} else {
  warning("ps_baseline contains no samples after filtering. Please check your input data and filtering criteria (time, carriage_group, batch). EDA and ANCOM-BC2 will not proceed.")
}

# --- Calculate and Add Alpha Diversity Metrics to ps_baseline ---
if (nsamples(ps_baseline) > 0) {
  if (is.null(otu_table(ps_baseline, errorIfNULL = FALSE)) || ntaxa(ps_baseline) == 0) {
      message("ps_baseline does not have a valid OTU table. Cannot calculate richness.")
  } else {
      alpha_metrics_to_calculate <- c("Shannon", "Simpson", "Observed")
      message(paste("Calculating alpha diversity metrics for ps_baseline:", paste(alpha_metrics_to_calculate, collapse=", ")))
      
      # CRITICAL: Ensure otu_table(ps_baseline) has raw counts for estimate_richness.
      # If 'ps' had relative abundances, this calculation for 'Observed'/'Chao1' might be incorrect.
      # Assuming 'ps' (and thus ps_baseline initially) contains appropriate raw counts.
      alpha_div_calculated <- estimate_richness(ps_baseline, measures = alpha_metrics_to_calculate)
      
      if (nrow(alpha_div_calculated) == nsamples(ps_baseline)) {
        # Add calculated metrics as new columns to the sample_data of ps_baseline
        for (metric_col in colnames(alpha_div_calculated)) {
          sample_data(ps_baseline)[[metric_col]] <- alpha_div_calculated[[metric_col]]
        }
        message("Alpha diversity metrics calculated and added to sample_data of ps_baseline.")
        # Verify
        # print("First few rows of ps_baseline sample_data with new alpha metrics:")
        # print(head(data.frame(sample_data(ps_baseline))[, c("carriage_group", "batch", alpha_metrics_to_calculate)]))
      } else {
        message("Error: Number of rows in calculated alpha diversity does not match number of samples in ps_baseline. Merge failed.")
      }
  }
} else {
    message("ps_baseline is empty, skipping alpha diversity calculation.")
}

# --- Check sample sizes for the ps_baseline object (now potentially with alpha metrics) ---
print("Sample counts for ps_baseline (Time 0, Acquisition vs. Non-carriers, Batch 4 excluded):")
if (nsamples(ps_baseline) > 0) {
  print(table(sample_data(ps_baseline)$carriage_group, sample_data(ps_baseline)$batch, dnn=c("Carriage Group", "Batch")))
  print(paste("Total samples in ps_baseline:", nsamples(ps_baseline)))

  if(min(table(sample_data(ps_baseline)$carriage_group)) < 10) {
    warning("Warning: One of the carriage groups in ps_baseline has fewer than 10 samples overall. Downstream results may be unstable.")
  } else {
    print("Both carriage groups in ps_baseline have adequate overall sample sizes (≥10).")
  }
  
  count_table <- table(sample_data(ps_baseline)$carriage_group, sample_data(ps_baseline)$batch)
  if (any(count_table > 0 & count_table < 3)) {
      warning("Some combinations of carriage_group and batch have very few samples (1 or 2). Faceted plots and within-batch statistical comparisons might be misleading or fail for these combinations.")
  }
} else {
  warning("ps_baseline contains no samples after initial filtering (before alpha calculation attempt). EDA and ANCOM-BC2 will not proceed.")
}
```

## 4. Exploratory Analysis of Baseline Susceptibility Groups (ps_baseline)
In this section, we explore the microbiome characteristics of the ps_baseline samples (Time 0, Acquisition vs. Non-carriers, Batch 4 excluded). All analyses will be faceted by or account for the remaining batches.

## 4.1 Alpha Diversity
We examine alpha diversity at baseline between Acquisition carriers and Non-carriers, faceted by batch.

```{r 4.1-alpha-div}
# Ensure ps_baseline is not empty before proceeding
# This is a minimal check; we assume ps_baseline is correctly populated from previous chunks.
if (nsamples(ps_baseline) == 0) {
  stop("ps_baseline is empty. Cannot proceed with alpha diversity analysis.")
}

alpha_metrics_to_plot <- c("Shannon", "Simpson", "Observed")
current_sample_data_df <- data.frame(sample_data(ps_baseline)) # Used for plotting and stats

# --- Plotting ---
alpha_plots_list <- list() # Optional: if you want to store plots

for(metric in alpha_metrics_to_plot) {
  
  # Ensure the metric column exists in the current sample data
  if (!metric %in% colnames(current_sample_data_df)) {
    message(paste("Metric '", metric, "' not found in sample_data of ps_baseline. Skipping this metric.", sep=""))
    next # Skip to the next metric
  }
  
  # Ensure factors for correct plotting order and faceting
  plot_df <- current_sample_data_df
  plot_df$carriage_group <- factor(plot_df$carriage_group, levels = c("Non_carrier", "Acquisition_carrier"))
  plot_df$batch <- factor(plot_df$batch)
  
  cat(paste("\n--- Plotting for metric:", metric, "---\n"))
  # Optional: print table for quick verification
  # print(table(plot_df$batch, plot_df$carriage_group, useNA = "ifany"))
      
  p <- ggpubr::ggboxplot(plot_df, 
                         x = "carriage_group", y = metric,
                         color = "carriage_group", palette = "jco", # Example palette
                         add = "jitter",
                         facet.by = "batch", 
                         short.panel.labs = FALSE) + 
    labs(title = paste("Baseline", metric, "Diversity (Acq vs. Non) by Batch"),
         x = "Carriage Group", y = paste(metric, "Index")) +
    theme_minimal(base_size = 10) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), 
          legend.position = "top",
          strip.text = element_text(size=10))
  
  # Add statistical comparison annotations for Batch 1 directly to the plot
  # This assumes Batch "1" exists and has both carriage groups.
  stat_test_batch1_for_plot <- plot_df %>%
    filter(batch == "1") %>%
    ggpubr::compare_means(as.formula(paste(metric, "~ carriage_group")), data = ., method = "wilcox.test") %>%
    mutate(y.position = max(plot_df[[metric]], na.rm = TRUE) * 1.05, # Adjust y.position as needed
           batch = "1") # Ensure the batch column is present for stat_pvalue_manual

  if(nrow(stat_test_batch1_for_plot) > 0 && "p.signif" %in% names(stat_test_batch1_for_plot)){
    p <- p + ggpubr::stat_pvalue_manual(
      stat_test_batch1_for_plot, 
      label = "p.signif",
      hide.ns = TRUE,
      tip.length = 0.01 # Optional: for brackets, if you use comparisons argument in compare_means
    )
  }
  
  alpha_plots_list[[metric]] <- p # Store the plot
  print(p)
  
  # --- Console output for Batch 1 statistics ---
  data_batch1 <- plot_df %>% filter(batch == "1")
  
  if (length(unique(data_batch1$carriage_group)) == 2 && sum(table(data_batch1$carriage_group) >= 3) == 2 && !all(is.na(data_batch1[[metric]]))) {
    # Ensure at least 3 samples per group in batch 1 for Wilcoxon test
    stat_test_batch1_console <- compare_means(as.formula(paste(metric, "~ carriage_group")), data = data_batch1, method = "wilcox.test")
    cat(paste("\nWilcoxon test for", metric, "in Batch 1 (Acquisition_carrier vs. Non_carrier):\n"))
    print(stat_test_batch1_console)
  } else {
    cat(paste("\nSkipping Wilcoxon test for", metric, "in Batch 1 due to insufficient samples in one or both groups (need N>=3 per group).\n"))
    print(table(data_batch1$carriage_group)) # Show counts for context
  }
}

```

### 4.2 Beta Diversity

We will now explore community-level differences (beta diversity) between "Acquisition_carrier" and "Non_carrier" groups at baseline, using Bray-Curtis dissimilarity and Principal Coordinate Analysis (PCoA). Plots will be faceted by batch, and PERMANOVA will be used to assess statistical significance while accounting for batch and cohort effects.

```{r 4.2-beta-div}
# Ensure ps_baseline is not empty and has enough samples for beta diversity
if (nsamples(ps_baseline) < 3) { # PCoA and PERMANOVA generally need at least 3 samples
  message("ps_baseline has fewer than 3 samples. Skipping beta diversity analysis.")
} else {

  # --- 1. Calculate Beta Diversity Metrics ---
  # We will calculate Bray-Curtis. Add others like "jaccard" if needed.
  # Note: phyloseq::distance calculates on the otu_table of ps_baseline.
  # Ensure otu_table(ps_baseline) contains appropriate data (counts or relative abundance).
  # Bray-Curtis is generally robust to data type (counts/proportions).
  
  message("Calculating Bray-Curtis dissimilarity on ps_baseline...")
  dist_bray_baseline <- phyloseq::distance(ps_baseline, method = "bray")
  # Optional: Calculate Jaccard
  # dist_jaccard_baseline <- phyloseq::distance(ps_baseline, method = "jaccard", binary = TRUE)

  # --- 2. Perform PCoA ---
  message("Performing PCoA on Bray-Curtis distances...")
  ord_pcoa_bray_baseline <- ordinate(ps_baseline, method = "PCoA", distance = dist_bray_baseline)

  # --- 3. Plot PCoA, Faceted by Batch ---
  if (!is.null(ord_pcoa_bray_baseline$vectors)) { # Check if ordination was successful
    
    # Ensure 'cohort' is a factor for plotting if it exists and will be used for shape
    sample_data_for_plot <- data.frame(sample_data(ps_baseline))
    if ("cohort" %in% colnames(sample_data_for_plot)) {
      sample_data_for_plot$cohort <- factor(sample_data_for_plot$cohort)
      # Update phyloseq object if cohort was not already a factor
      if(!is.factor(sample_data(ps_baseline)$cohort)){
          sample_data(ps_baseline)$cohort <- factor(sample_data(ps_baseline)$cohort)
      }
    }
    
    # Extract explained variance for axis labels if available
    axis_labels <- c("PCo1", "PCo2") # Default labels
    if(!is.null(ord_pcoa_bray_baseline$values) && "Relative_eig" %in% names(ord_pcoa_bray_baseline$values)){
        eigen_vals <- ord_pcoa_bray_baseline$values$Relative_eig
        axis_labels <- c(paste0("PCo1 [", round(eigen_vals[1]*100, 1), "%]"),
                         paste0("PCo2 [", round(eigen_vals[2]*100, 1), "%]"))
    }


    beta_plot_baseline <- plot_ordination(ps_baseline, ord_pcoa_bray_baseline, 
                                       color = "carriage_group", 
                                       shape = if("cohort" %in% names(sample_data(ps_baseline))) "cohort" else NULL) + # Use cohort for shape if available
      geom_point(size = 3, alpha = 0.75) +
      stat_ellipse(aes(group = carriage_group, fill = carriage_group), geom = "polygon", alpha = 0.2, show.legend = FALSE, type = "t") +
      facet_wrap(~batch) + 
      labs(title = "PCoA (Bray-Curtis) at Baseline (Acq vs. Non) by Batch",
           x = axis_labels[1], y = axis_labels[2],
           color = "Carriage Group", 
           shape = if("cohort" %in% names(sample_data(ps_baseline))) "Cohort" else NULL) +
      theme_bw(base_size = 10) +
      theme(legend.position = "top", strip.text = element_text(size=10))
    
    print(beta_plot_baseline)
  } else {
    message("PCoA ordination failed. Cannot plot beta diversity.")
  }

  # --- 4. PERMANOVA Tests ---
  sample_df_baseline <- data.frame(sample_data(ps_baseline))
  
  # Ensure there's enough data for PERMANOVA
  if (nrow(sample_df_baseline) >= 3 && 
      length(unique(sample_df_baseline$carriage_group)) > 1 &&
      length(unique(sample_df_baseline$batch)) > 0 ) { # Batch needs to exist

    # PERMANOVA 1: Accounting for batch
    cat("\n--- PERMANOVA (carriage_group + batch) ---\n")
    permanova_res_batch <- vegan::adonis2(
      dist_bray_baseline ~ carriage_group + batch, 
      data = sample_df_baseline, 
      permutations = 999,
      by = "terms" # Test terms sequentially
    )
    print(permanova_res_batch)

    # PERMANOVA 2: Accounting for batch AND cohort (if cohort exists and has >1 level)
    if ("cohort" %in% colnames(sample_df_baseline) && length(unique(sample_df_baseline$cohort)) > 1) {
      cat("\n--- PERMANOVA (carriage_group + batch + cohort) ---\n")
      permanova_res_batch_cohort <- vegan::adonis2(
        dist_bray_baseline ~ carriage_group + batch + cohort, 
        data = sample_df_baseline, 
        permutations = 999,
        by = "terms"
      )
      print(permanova_res_batch_cohort)
    } else {
      message("Cohort variable not suitable for PERMANOVA (missing, or only one level). Skipping PERMANOVA with cohort.")
    }
  } else {
    message("Skipping PERMANOVA due to insufficient samples, groups, or batch variation in ps_baseline.")
  }
}

# Optional: Display relevant beta diversity plots from preprocessing for context
# These might show all time points or different subsets.
preprocessing_plot_path_beta_longitudinal <- "../results/preprocessing_plots/longitudinal_pcoa_faceted_susc_analysis.png" 
if (file.exists(preprocessing_plot_path_beta_longitudinal)) {
  # print("Displaying pre-generated longitudinal PCoA plot from preprocessing (shows all time points for Acq vs Non):")
  # knitr::include_graphics(preprocessing_plot_path_beta_longitudinal) 
  # cat("Note: Baseline samples from 'Acquisition_carrier' and 'Non_carrier' groups are the starting points of trajectories in the plot above.\n")
}

```

### 4.3 Taxonomic Composition

We will visualize the relative abundance of major genera at baseline to compare "Acquisition_carrier" and "Non_carrier" groups, faceted by batch.

```{r 4.3-taxonomic-composition}
# Ensure ps_baseline is not empty
if (nsamples(ps_baseline) == 0) {
  stop("ps_baseline is empty. Cannot proceed with taxonomic composition analysis.")
}

# --- 1. Aggregate to Genus Level ---
# NArm = FALSE will keep taxa that are unclassified at the Genus level, naming them by the lowest known rank
ps_baseline_genus <- tax_glom(ps_baseline, taxrank = "Genus", NArm = FALSE) 

# --- 2. Transform to Relative Abundance ---
ps_baseline_genus_rel <- transform_sample_counts(ps_baseline_genus, function(x) x / sum(x))

# --- 3. Identify Top N Genera for Plotting Clarity ---
# Calculate mean abundance of each genus across all samples in ps_baseline_genus_rel
mean_abund <- taxa_sums(ps_baseline_genus_rel) / nsamples(ps_baseline_genus_rel) # Simpler way to get overall means
topN_genera <- 15 # Or your desired number
# Handle cases where total taxa < topN_genera
num_taxa_to_plot <- min(topN_genera, ntaxa(ps_baseline_genus_rel))

if (num_taxa_to_plot > 0) {
  top_genera_names <- names(sort(mean_abund, decreasing = TRUE)[1:num_taxa_to_plot])
  
  # Prune to top N genera for plotting. This object can be directly used by plot_bar.
  ps_plot_data_taxa_topN <- prune_taxa(top_genera_names, ps_baseline_genus_rel)
  
  # For plot_bar, phyloseq often handles the "Others" category implicitly if you plot relative abundances.
  # If not, you might need to manually create an "Others" category.
  # A simpler approach for direct ggplot2 if needed for more control:
  # df_plot_taxa <- psmelt(ps_plot_data_taxa_topN)
  
  # --- 4. Create Stacked Bar Plot ---
  # Ensure SampleID is unique or make a unique plotting ID if needed for x-axis
  sample_data(ps_plot_data_taxa_topN)$plot_sample_id <- make.names(sample_names(ps_plot_data_taxa_topN), unique=TRUE)

  taxa_comp_plot_baseline <- plot_bar(ps_plot_data_taxa_topN, x = "plot_sample_id", fill = "Genus") +
    geom_bar(stat = "identity", position = "stack") +
    facet_grid(batch ~ carriage_group, scales = "free_x", space = "free_x") + # Facet by batch then carriage_group
    labs(title = paste("Baseline Top", num_taxa_to_plot, "Genera (Acq vs. Non) by Batch & Group"),
         x = "Sample", 
         y = "Relative Abundance") +
    theme_minimal(base_size = 9) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 5), 
          legend.position = "bottom",
          legend.title = element_text(size=8), 
          legend.text = element_text(size=7),
          strip.text = element_text(size=8)) +
    guides(fill = guide_legend(nrow = 3, title.position = "top")) # Adjust legend rows and title position

  print(taxa_comp_plot_baseline)

  # (Optional: Heatmap of mean abundances - code would go here)

} else {
  message("No taxa to plot after filtering for top genera, or ps_baseline_genus_rel is empty.")
}

```

## 5. Differential Abundance Analysis with ANCOM-BC2 (Baseline)

We will now use ANCOM-BC2 to identify differentially abundant genera at baseline between "Acquisition_carrier" and "Non_carrier" groups, while controlling for batch and other relevant covariates.

```{r ancombc2-baseline-models}
# Ensure ps_baseline is ready and has necessary sample data columns
if (nsamples(ps_baseline) == 0) {
  stop("ps_baseline is empty. Cannot proceed with ANCOM-BC2 analysis.")
}

# Check for NAs in covariates that will be used in models and handle if necessary
# For simplicity, this example assumes covariates are mostly complete or NAs are acceptable by ancombc2 
# (often they lead to sample exclusion for that model).
# A more robust approach would involve checking and explicitly deciding how to handle NAs (e.g., imputation or removal).

sample_vars <- colnames(data.frame(sample_data(ps_baseline)))
required_vars_model3 <- c("carriage_group", "batch", "selfsmoking", "boardingschool")
required_vars_model4 <- c("carriage_group", "batch", "cohort", "selfsmoking", "boardingschool", "AB_month") # Example full model

# Check if all required variables exist
if (!all(required_vars_model3 %in% sample_vars)) {
    stop(paste("Missing one or more required covariates for Model 3 in ps_baseline sample_data:", 
               paste(required_vars_model3[!required_vars_model3 %in% sample_vars], collapse=", ")))
}
if (!all(required_vars_model4 %in% sample_vars)) {
    stop(paste("Missing one or more required covariates for Model 4 in ps_baseline sample_data:",
               paste(required_vars_model4[!required_vars_model4 %in% sample_vars], collapse=", ")))
}

# Ensure covariates are factors if they are categorical
# This should have been handled during data loading, but double-check common ones
if (!is.factor(sample_data(ps_baseline)$batch)) sample_data(ps_baseline)$batch <- factor(sample_data(ps_baseline)$batch)
if (!is.factor(sample_data(ps_baseline)$cohort)) sample_data(ps_baseline)$cohort <- factor(sample_data(ps_baseline)$cohort)
if ("selfsmoking" %in% sample_vars && !is.factor(sample_data(ps_baseline)$selfsmoking)) sample_data(ps_baseline)$selfsmoking <- factor(sample_data(ps_baseline)$selfsmoking)
if ("boardingschool" %in% sample_vars && !is.factor(sample_data(ps_baseline)$boardingschool)) sample_data(ps_baseline)$boardingschool <- factor(sample_data(ps_baseline)$boardingschool)
if ("AB_month" %in% sample_vars && !is.factor(sample_data(ps_baseline)$AB_month)) sample_data(ps_baseline)$AB_month <- factor(sample_data(ps_baseline)$AB_month)


# Initialize list to store model results
baseline_ancom_models <- list()

# Set common ANCOM-BC2 parameters
tax_level_to_analyze <- "Genus"
set.seed(123) # for reproducibility

# --- Model 1: carriage_group + batch ---
message("Running ANCOM-BC2 Model 1: carriage_group + batch")
tryCatch({
  baseline_ancom_models$m1_cg_batch <- ancombc2(
    data = ps_baseline,
    tax_level = tax_level_to_analyze,
    fix_formula = "carriage_group + batch", # carriage_group is the primary variable of interest
    p_adj_method = "holm",
    pseudo_sens = TRUE,
    prv_cut = 0.10, # Present in at least 10% of samples
    lib_cut = 1000, # Minimum library size
    group = "carriage_group", # Explicitly defining the main group for comparison
    struc_zero = TRUE,
    neg_lb = TRUE,
    alpha = 0.05,
    n_cl = 1, # Use 1 core for sequential running, or 2+ if your machine supports for faster individual model runs
    verbose = TRUE,
    pairwise = TRUE # Technically redundant if group has 2 levels, but good practice
  )
}, error = function(e) {
  message("Error in ANCOM-BC2 Model 1: ", e$message)
  baseline_ancom_models$m1_cg_batch <- list(error = e$message)
})

# --- Model 2: carriage_group + batch + cohort ---
message("Running ANCOM-BC2 Model 2: carriage_group + batch + cohort")
tryCatch({
  baseline_ancom_models$m2_cg_batch_cohort <- ancombc2(
    data = ps_baseline,
    tax_level = tax_level_to_analyze,
    fix_formula = "carriage_group + batch + cohort",
    p_adj_method = "holm",
    pseudo_sens = TRUE,
    prv_cut = 0.10,
    lib_cut = 1000,
    group = "carriage_group",
    struc_zero = TRUE,
    neg_lb = TRUE,
    alpha = 0.05,
    n_cl = 1,
    verbose = TRUE,
    pairwise = TRUE
  )
}, error = function(e) {
  message("Error in ANCOM-BC2 Model 2: ", e$message)
  baseline_ancom_models$m2_cg_batch_cohort <- list(error = e$message)
})

# --- Model 3: carriage_group + batch + selfsmoking + boardingschool ---
# Based on original study's findings for risk factors for NM carriage
message("Running ANCOM-BC2 Model 3: carriage_group + batch + key demographics (smoking, boarding)")
tryCatch({
  baseline_ancom_models$m3_cg_batch_demog <- ancombc2(
    data = ps_baseline,
    tax_level = tax_level_to_analyze,
    fix_formula = "carriage_group + batch + selfsmoking + boardingschool",
    p_adj_method = "holm",
    pseudo_sens = TRUE,
    prv_cut = 0.10,
    lib_cut = 1000,
    group = "carriage_group",
    struc_zero = TRUE,
    neg_lb = TRUE,
    alpha = 0.05,
    n_cl = 1,
    verbose = TRUE,
    pairwise = TRUE
  )
}, error = function(e) {
  message("Error in ANCOM-BC2 Model 3: ", e$message)
  baseline_ancom_models$m3_cg_batch_demog <- list(error = e$message)
})

# --- Model 4: Full model - carriage_group + batch + cohort + selfsmoking + boardingschool + AB_month ---
message("Running ANCOM-BC2 Model 4: Full model")
tryCatch({
  baseline_ancom_models$m4_cg_batch_cohort_fulldemog <- ancombc2(
    data = ps_baseline,
    tax_level = tax_level_to_analyze,
    fix_formula = "carriage_group + batch + cohort + selfsmoking + boardingschool + AB_month",
    p_adj_method = "holm",
    pseudo_sens = TRUE,
    prv_cut = 0.10,
    lib_cut = 1000,
    group = "carriage_group",
    struc_zero = TRUE,
    neg_lb = TRUE,
    alpha = 0.05,
    n_cl = 1,
    verbose = TRUE,
    pairwise = TRUE
  )
}, error = function(e) {
  message("Error in ANCOM-BC2 Model 4: ", e$message)
  baseline_ancom_models$m4_cg_batch_cohort_fulldemog <- list(error = e$message)
})

# --- Save the list of models ---
# Ensure the results directory exists (should be created in setup chunk)
ancom_results_rds_file <- file.path(results_dir, "baseline_susceptibility_ancombc2_models.rds")
saveRDS(baseline_ancom_models, file = ancom_results_rds_file)
message(paste("ANCOM-BC2 model results saved to:", ancom_results_rds_file))

# Print summary of what was run
print("Summary of ANCOM-BC2 models run:")
print(names(baseline_ancom_models))
lapply(baseline_ancom_models, function(model) {
  if (!is.null(model$res)) {
    cat(paste("\nModel Formula:", model$formula, "\n"))
    cat(paste("Number of taxa passed filter:", nrow(model$feature_table), "\n"))
    # Count significant for the primary comparison (Acquisition_carrier vs Non_carrier)
    # The exact column name depends on your reference level for carriage_group.
    # Assuming Non_carrier is reference, the effect for Acquisition_carrier would be in lfc_carriage_groupAcquisition_carrier
    # and diff_carriage_groupAcquisition_carrier
    
    # Find the relevant diff column dynamically
    diff_col_name <- grep("^diff_carriage_group", names(model$res), value = TRUE)
    if(length(diff_col_name) == 1){
        sig_count <- sum(model$res[[diff_col_name]], na.rm = TRUE)
        cat(paste("Number of significantly DA taxa for carriage_group:", sig_count, "\n"))
    } else {
        cat("Could not uniquely identify differential abundance column for carriage_group.\n")
    }
    
  } else if (!is.null(model$error)) {
    cat(paste("\nModel failed with error:", model$error, "\n"))
  } else {
    cat("\nModel object structure not as expected or model did not run.\n")
  }
})
```

```{r load-ancombc2-baseline-models, include=FALSE}
# # Define the path to the saved ANCOM-BC2 model results
ancom_results_rds_file <- file.path(results_dir, "baseline_susceptibility_ancombc2_models.rds")

# # Initialize an empty list for the models
baseline_ancom_models <- list()

# # Check if the RDS file exists
if (file.exists(ancom_results_rds_file)) {
  # If it exists, load the models from the RDS file
  message(paste("Loading existing ANCOM-BC2 models from:", ancom_results_rds_file))
  baseline_ancom_models <- readRDS(ancom_results_rds_file)
  
  # Optional: Briefly verify the loaded models (e.g., print names)
  print("Loaded ANCOM-BC2 model names:")
  print(names(baseline_ancom_models))
  
  # Set a flag to skip model generation if they are successfully loaded
  # This assumes you'll add a condition to your model generation chunk
  # For example: if (!exists("models_loaded_successfully") || !models_loaded_successfully) { ... run models ... }
  # For now, we are simply loading them if they exist. The ancombc2-baseline-models chunk will overwrite this object if run.
  # A more robust approach for skipping re-running would be to comment out the model fitting chunk itself.

} else {
  message(paste("ANCOM-BC2 model RDS file not found at:", ancom_results_rds_file, ". Models will be generated if the next chunk is run."))
}
```














## 5. [OLD]Differential Abundance Analysis with ANCOM-BC2

We'll use ANCOM-BC2 to identify differentially abundant taxa between the original carriage groups, while accounting for potential confounding factors.

```{r ancom-bc2-analysis}
# Set random seed for reproducibility
set.seed(123)


# Run function directly
ancombc2_result <- ancombc2(
  data = ps_suscept_original,
  tax_level = "Genus",
  fix_formula = "carriage_group + batch",
  rand_formula = NULL,
  p_adj_method = "holm",
  pseudo_sens = TRUE,
  prv_cut = 0.025,
  lib_cut = 1000,
  s0_perc = 0.1,
  group = "carriage_group",
  struc_zero = TRUE,
  neg_lb = TRUE,
  alpha = 0.05,
  n_cl = 2,
  global = FALSE,
  pairwise = TRUE,
  verbose = TRUE
)

# # Run ANCOM-BC2 using our custom function, now using carriage_group
# ancombc2_result <- run_ancombc2(
#   ps_object = ps_suscept_original,
#   tax_level = "Genus",
#   formula_str = "carriage_group + selfsmoking + boardingschool + AB_month",
#   group_var = "carriage_group",
#   prv_cut = 0.025,
#   seed = 123
# )

# Save the results
saveRDS(ancombc2_result, file = file.path(results_dir, "ancombc2_original_susceptibility_results.rds"))

# Extract basic results to check
res_primary <- ancombc2_result$res
print(paste("Total number of taxa analyzed:", nrow(res_primary)))

# Get the column names related to log fold changes and differential abundance
lfc_cols <- grep("^lfc_", colnames(res_primary), value = TRUE)
diff_cols <- grep("^diff_", colnames(res_primary), value = TRUE)
print("Comparisons in the results:")
print(gsub("^lfc_", "", lfc_cols))

# Count the number of significant taxa for each comparison
for(i in seq_along(diff_cols)) {
  comparison <- gsub("^diff_", "", diff_cols[i])
  n_sig <- sum(res_primary[[diff_cols[i]]] == 1)
  
  ss_col <- paste0("passed_ss_", comparison)
  if(ss_col %in% colnames(res_primary)) {
    n_sig_with_ss <- sum(res_primary[[diff_cols[i]]] == 1 & 
                         res_primary[[ss_col]] == TRUE)
    
    print(paste0("Comparison ", comparison, ":"))
    print(paste0("  - Significant taxa: ", n_sig))
    print(paste0("  - Significant taxa passing sensitivity score: ", n_sig_with_ss))
  } else {
    print(paste0("Comparison ", comparison, ": ", n_sig, " significant taxa"))
  }
}
```

## 6. Visualization of Significant Taxa

```{r visualize-results}
# Visualize ANCOM-BC2 results using our custom function
ancombc2_vis <- visualize_ancombc2_results(
  ancombc2_result,
  title = "Original Susceptibility Analysis"
)

# Display the plots
if(length(ancombc2_vis$plots) > 0) {
  for(plot_name in names(ancombc2_vis$plots)) {
    print(ancombc2_vis$plots[[plot_name]])
    
    # Save the plots
    ggsave(file.path(results_dir, paste0("diff_abundant_taxa_", plot_name, ".png")), 
           ancombc2_vis$plots[[plot_name]], width = 10, height = 8)
  }
} else {
  print("No significant taxa found to visualize.")
}

# Display a summary table of significant taxa
display_results <- function(vis_results, title) {
  cat("\n====== ", title, " ======\n")
  
  # Check if there are significant results
  if(length(vis_results$sig_taxa) == 0) {
    cat("No significant differential abundance detected.\n")
    return(NULL)
  }
  
  # Display results for each comparison
  for(comparison in names(vis_results$sig_taxa)) {
    sig_taxa <- vis_results$sig_taxa[[comparison]]
    
    if(nrow(sig_taxa) > 0) {
      cat("\nComparison:", comparison, "\n")
      cat("Number of significant taxa:", nrow(sig_taxa), "\n")
      
      # Create a data frame for display
      result_df <- sig_taxa %>% 
        select(taxon, lfc) %>%
        arrange(desc(abs(lfc)))
      
      # Display the data frame
      print(result_df)
    }
  }
}

# Display the results summary
display_results(ancombc2_vis, "SIGNIFICANT TAXA FOR ORIGINAL SUSCEPTIBILITY ANALYSIS")

# Save significant taxa results to CSV
for(comparison in names(ancombc2_vis$sig_taxa)) {
  if(length(ancombc2_vis$sig_taxa[[comparison]]) > 0 && nrow(ancombc2_vis$sig_taxa[[comparison]]) > 0) {
    write.csv(
      ancombc2_vis$sig_taxa[[comparison]],
      file = file.path(results_dir, paste0("sig_taxa_", comparison, ".csv")),
      row.names = FALSE
    )
  }
}

# Extract significant taxa across all comparisons
all_sig_taxa <- unique(unlist(lapply(ancombc2_vis$sig_taxa, function(x) x$taxon)))

# Create a heatmap of significant taxa abundances
if(length(all_sig_taxa) > 0) {
  # First, create a tax-glom'ed version of the phyloseq object at the genus level
  ps_genus <- tax_glom(ps_suscept_original, taxrank = "Genus")
  
  # Function to map between ANCOM-BC2 taxa names and phyloseq taxa
  create_taxa_mapping <- function(ps_obj, ancombc2_taxa) {
    # Extract tax table
    tax_df <- as.data.frame(tax_table(ps_obj))
    
    # Create a mapping dictionary
    taxa_map <- list()
    
    # Process each ANCOM-BC2 taxon name
    for (taxon_name in ancombc2_taxa) {
      # Parse the taxon name to extract level and value
      if (grepl(":", taxon_name)) {
        # Format is "Level:Name"
        parts <- strsplit(taxon_name, ":")[[1]]
        level <- parts[1]
        value <- parts[2]
        
        # Find matching taxa in the phyloseq object
        if (level %in% colnames(tax_df)) {
          matching_indices <- which(tax_df[[level]] == value)
          if (length(matching_indices) > 0) {
            taxa_map[[taxon_name]] <- rownames(tax_df)[matching_indices]
          }
        }
      } else {
        # Try to find a direct match
        if (taxon_name %in% rownames(tax_df)) {
          taxa_map[[taxon_name]] <- taxon_name
        }
      }
    }
    
    return(taxa_map)
  }
  
  # Function to create a heatmap using the mapped taxa
  create_mapped_heatmap <- function(ps_obj, ancombc2_taxa, group_var) {
    # Get taxa mapping
    taxa_mapping <- create_taxa_mapping(ps_obj, ancombc2_taxa)
    
    # Check if we found any matches
    if (length(taxa_mapping) == 0) {
      warning("No matching taxa found in the phyloseq object")
      return(NULL)
    }
    
    message(sprintf("Found %d matching taxa out of %d significant taxa", 
                    length(taxa_mapping), length(ancombc2_taxa)))
    
    # Flatten the mapping to get all matching taxa IDs
    all_matching_taxa <- unique(unlist(taxa_mapping))
    
    # Subset the phyloseq object to only include matching taxa
    ps_subset <- prune_taxa(all_matching_taxa, ps_obj)
    
    # Transform to relative abundance
    ps_rel <- transform_sample_counts(ps_subset, function(x) x / sum(x))
    
    # Extract abundance data
    abund_mat <- as(otu_table(ps_rel), "matrix")
    if (taxa_are_rows(ps_rel)) {
      abund_mat <- t(abund_mat)
    }
    
    # Get the taxonomy information for labeling
    tax_info <- as.data.frame(tax_table(ps_rel))
    
    # Create row labels using genus and family
    row_labels <- apply(tax_info, 1, function(x) {
      if (!is.na(x["Genus"]) && x["Genus"] != "") {
        return(x["Genus"])
      } else if (!is.na(x["Family"]) && x["Family"] != "") {
        return(paste0(x["Family"], " (unknown genus)"))
      } else {
        return(rownames(tax_info)[which(rownames(tax_info) == rownames(tax_info)[which(tax_info[,1] == x[1])])[1]])
      }
    })
    names(row_labels) <- rownames(tax_info)
    
    # Get sample metadata
    sample_meta <- data.frame(sample_data(ps_rel))
    group_data <- sample_meta[[group_var]]
    
    # Create a data frame for ggplot
    abund_df <- as.data.frame(abund_mat)
    abund_df$SampleID <- rownames(abund_df)
    abund_df$Group <- group_data
    
    # Reshape to long format
    abund_long <- abund_df %>%
      pivot_longer(cols = -c(SampleID, Group),
                  names_to = "Taxon",
                  values_to = "Abundance") %>%
      mutate(TaxonLabel = row_labels[Taxon])
    
    # Create heatmap
    heatmap_plot <- ggplot(abund_long, aes(x = SampleID, y = TaxonLabel, fill = Abundance)) +
      geom_tile() +
      facet_grid(. ~ Group, scales = "free_x", space = "free_x") +
      scale_fill_viridis_c(name = "Relative\nAbundance") +
      labs(title = paste("Abundance of Significant Taxa by", group_var),
           x = "Sample", y = "Taxon") +
      theme_minimal() +
      theme(axis.text.x = element_blank(),
            axis.ticks.x = element_blank())
    
    return(heatmap_plot)
  }
  
  # Create and display the heatmap
  heatmap_plot <- create_mapped_heatmap(ps_genus, all_sig_taxa, "carriage_group")
  if (!is.null(heatmap_plot)) {
    print(heatmap_plot)
    ggsave(file.path(results_dir, "significant_taxa_heatmap.png"), 
           heatmap_plot, width = 12, height = 8)
  } else {
    message("Could not create heatmap - no matching taxa found")
  }
} else {
  message("No significant taxa found to display in heatmap")
}
```

## 7. Covariate Importance Analysis

In addition to carriage status, we included several covariates in our model. Here we'll examine their associations with taxa abundance.

```{r covariate-importance}
# Extract covariate results from ANCOM-BC2
covariate_results <- list()
covariate_cols <- c("selfsmoking", "boardingschool", "AB_month")

for(covar in covariate_cols) {
  # Get relevant columns for this covariate
  lfc_col <- grep(paste0("^lfc_", covar), colnames(res_primary), value = TRUE)
  diff_col <- grep(paste0("^diff_", covar), colnames(res_primary), value = TRUE)
  
  if(length(lfc_col) > 0 && length(diff_col) > 0) {
    # Filter for significant taxa associated with this covariate
    sig_taxa <- res_primary %>%
      filter(!!sym(diff_col) == 1) %>%
      select(taxon, !!sym(lfc_col)) %>%
      rename(lfc = !!sym(lfc_col)) %>%
      arrange(desc(abs(lfc)))
    
    covariate_results[[covar]] <- sig_taxa
    
    # Print summary
    cat("\nSignificant taxa associated with", covar, ":", nrow(sig_taxa), "\n")
    if(nrow(sig_taxa) > 0) {
      print(head(sig_taxa, 10))
    }
  }
}

# Visualize significant taxa for each covariate
for(covar in names(covariate_results)) {
  if(nrow(covariate_results[[covar]]) > 0) {
    # Limit to top 15 taxa by absolute log fold change
    top_n_taxa <- min(nrow(covariate_results[[covar]]), 15)
    plot_data <- covariate_results[[covar]][1:top_n_taxa, ]
    
    # Create bar plot
    p <- ggplot(plot_data, aes(x = reorder(taxon, lfc), y = lfc, 
                             fill = lfc > 0)) +
      geom_bar(stat = "identity") +
      scale_fill_manual(values = c("#619CFF", "#F8766D"), 
                      name = "Direction", 
                      labels = c("Decreased", "Increased")) +
      labs(title = paste("Taxa associated with", covar),
           x = "Taxon",
           y = "Log Fold Change") +
      coord_flip() +
      theme_minimal()
    
    print(p)
    
    # Save the plot
    ggsave(file.path(results_dir, paste0("covariate_", covar, "_taxa.png")), 
           p, width = 10, height = 6)
  }
}
```

## 8. Interpretation and Biological Significance

In this section, we'll interpret the biological significance of the differentially abundant taxa identified in our analysis.

```{r biological-interpretation}
# Extract the names of significant taxa that passed sensitivity score filter
sig_taxa_passing_ss <- list()

for(comparison in names(ancombc2_vis$sig_taxa)) {
  sig_taxa_df <- ancombc2_vis$sig_taxa[[comparison]]
  if(!is.null(sig_taxa_df) && nrow(sig_taxa_df) > 0) {
    # Get taxon names, assuming they're already filtered for significance and sensitivity
    sig_taxa_passing_ss[[comparison]] <- sig_taxa_df$taxon
  }
}

# Get the full taxonomy information for significant taxa
get_taxa_table <- function(ps_obj, taxa_names) {
  if(length(taxa_names) == 0) return(NULL)
  
  # Extract tax table
  tax_table <- as.data.frame(tax_table(ps_obj))
  
  # Filter for significant taxa
  sig_tax_table <- tax_table[rownames(tax_table) %in% taxa_names, ]
  
  # Add taxon name as a column
  sig_tax_table$taxon <- rownames(sig_tax_table)
  
  return(sig_tax_table)
}

# Print taxonomic information for significant taxa
for(comparison in names(sig_taxa_passing_ss)) {
  cat("\n=== Taxonomy of significant taxa for", comparison, "===\n")
  taxa_names <- sig_taxa_passing_ss[[comparison]]
  
  if(length(taxa_names) > 0) {
    taxa_table <- get_taxa_table(ps_suscept_original, taxa_names)
    if(!is.null(taxa_table)) {
      print(taxa_table)
    }
  } else {
    cat("No significant taxa passing sensitivity score filter\n")
  }
}

# Summarize key findings
cat("\n=== Key findings from original susceptibility analysis ===\n")

# Count total significant taxa
total_sig_taxa <- unique(unlist(sig_taxa_passing_ss))
cat("Total unique significant taxa identified:", length(total_sig_taxa), "\n")

# Highlight taxonomic patterns
if(length(total_sig_taxa) > 0) {
  all_tax_table <- get_taxa_table(ps_suscept_original, total_sig_taxa)
  if(!is.null(all_tax_table)) {
    # Summarize at Phylum level
    phylum_summary <- all_tax_table %>%
      group_by(Phylum) %>%
      summarise(count = n()) %>%
      arrange(desc(count))
    
    cat("\nPhylum distribution of significant taxa:\n")
    print(phylum_summary)
    
    # Summarize at Family level
    family_summary <- all_tax_table %>%
      group_by(Family) %>%
      summarise(count = n()) %>%
      arrange(desc(count))
    
    cat("\nFamily distribution of significant taxa:\n")
    print(head(family_summary, 10))
  }
} else {
  cat("No significant taxa to summarize taxonomic patterns\n")
}
```

## 9. Comparison with Expanded Susceptibility Analysis

Here we'll compare results from our original carriage group analysis with the expanded susceptibility analysis to see if there are consistent taxa signatures.

```{r compare-analyses}
# Check if the expanded analysis results exist
expanded_results_file <- file.path("../results", "ancombc2_susceptibility_results.rds")
if(file.exists(expanded_results_file)) {
  # Load the expanded analysis results
  expanded_results <- readRDS(expanded_results_file)
  expanded_res_primary <- expanded_results$res
  
  # Extract significant taxa from expanded analysis
  expanded_sig_taxa <- list()
  exp_diff_cols <- grep("^diff_", colnames(expanded_res_primary), value = TRUE)
  
  for(diff_col in exp_diff_cols) {
    comparison <- gsub("^diff_", "", diff_col)
    ss_col <- paste0("passed_ss_", comparison)
    
    if(ss_col %in% colnames(expanded_res_primary)) {
      sig_taxa <- expanded_res_primary$taxon[
        expanded_res_primary[[diff_col]] == 1 & 
        expanded_res_primary[[ss_col]] == TRUE
      ]
    } else {
      sig_taxa <- expanded_res_primary$taxon[expanded_res_primary[[diff_col]] == 1]
    }
    
    expanded_sig_taxa[[comparison]] <- sig_taxa
  }
  
  # Compare with current results
  cat("\n=== Comparison with Expanded Susceptibility Analysis ===\n")
  
  # Find overlap in significant taxa
  all_expanded_sig_taxa <- unique(unlist(expanded_sig_taxa))
  
  if(length(total_sig_taxa) > 0 && length(all_expanded_sig_taxa) > 0) {
    overlap_taxa <- intersect(total_sig_taxa, all_expanded_sig_taxa)
    
    cat("Total significant taxa in original analysis:", length(total_sig_taxa), "\n")
    cat("Total significant taxa in expanded analysis:", length(all_expanded_sig_taxa), "\n")
    cat("Number of overlapping taxa:", length(overlap_taxa), "\n")
    
    if(length(overlap_taxa) > 0) {
      cat("\nOverlapping taxa:\n")
      overlap_tax_table <- get_taxa_table(ps_suscept_original, overlap_taxa)
      if(!is.null(overlap_tax_table)) {
        print(overlap_tax_table %>% select(Phylum, Class, Order, Family, Genus, taxon))
      }
    }
  } else {
    cat("No overlapping significant taxa found between the analyses\n")
  }
} else {
  cat("Expanded analysis results not found. Skipping comparison.\n")
}
```

## 10. Export Results and Visualizations

```{r export-results}
# Save the full ANCOM-BC2 results object
saveRDS(ancombc2_result, file = file.path(results_dir, "original_susceptibility_ancombc2_results.rds"))

# Save the visualization results
saveRDS(ancombc2_vis, file = file.path(results_dir, "original_susceptibility_visualization_results.rds"))

# Create a summary of significant findings
susceptibility_summary <- list(
  analysis_info = list(
    date = Sys.Date(),
    samples_analyzed = nrow(sample_data(ps_suscept_original)),
    group_sizes = table(sample_data(ps_suscept_original)$carriage_group),
    covariates = c("selfsmoking", "boardingschool", "AB_month")
  ),
  significance_summary = list(
    total_taxa_analyzed = nrow(res_primary),
    significant_taxa = lapply(diff_cols, function(col) sum(res_primary[[col]] == 1)),
    significant_taxa_passing_ss = lapply(diff_cols, function(col) {
      ss_col <- gsub("diff_", "passed_ss_", col)
      if(ss_col %in% colnames(res_primary)) {
        sum(res_primary[[col]] == 1 & res_primary[[ss_col]] == TRUE)
      } else {
        sum(res_primary[[col]] == 1)
      }
    })
  ),
  differentially_abundant_taxa = sig_taxa_passing_ss
)

# Save the summary
saveRDS(susceptibility_summary, 
       file = file.path(results_dir, "original_susceptibility_analysis_summary.rds"))

# Save a text summary of results
sink(file = file.path(results_dir, "original_susceptibility_results_summary.txt"))
cat("=== NM ORIGINAL SUSCEPTIBILITY ANALYSIS RESULTS ===\n\n")
cat("Analysis Date:", as.character(Sys.Date()), "\n")
cat("Samples Analyzed:", nrow(sample_data(ps_suscept_original)), "\n")
cat("Group Sizes:\n")
print(table(sample_data(ps_suscept_original)$carriage_group))
cat("\n")

cat("=== SIGNIFICANT TAXA ===\n\n")
display_results(ancombc2_vis, "SIGNIFICANT TAXA FOR ORIGINAL SUSCEPTIBILITY ANALYSIS")
cat("\n")

cat("=== PERMANOVA RESULTS ===\n\n")
print(permanova_result)
cat("\n")

sink()
```

## 11. Session Info

```{r session-info}
sessionInfo()
```