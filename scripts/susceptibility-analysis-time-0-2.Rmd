---
title: "susceptibility-analysis-time-0-2.rmd"
author: "orr tobaly & nikol elyashov"
date: "2025-05-20"
output: pdf_document
editor_options: 
  chunk_output_type: console
---
## 0. chunk setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(
echo = TRUE,        # Display code chunks
warning = FALSE,    # Hide warnings
message = FALSE,    # Hide messages
fig.width = 10,     # Default figure width
fig.height = 6      # Default figure height
)
```

## 1. Setup and Library Loading
Purpose: This chunk loads all required R packages for the analysis, sources custom R scripts containing helper functions, and defines the file paths for input data and output results. It also creates the results directory if it doesn't already exist.

```{r}
# Load required packages
library(phyloseq)        # Microbiome data handling
library(ANCOMBC)         # For ANCOM-BC2 analysis
library(dplyr)           # Data manipulation
library(ggplot2)         # Plotting
library(tidyr)           # Data tidying
library(readxl)          # Reading Excel files (if needed for any additional metadata)
library(DT)              # Interactive tables
library(patchwork)       # Combining plots
library(microbiome)      # Core microbiome utilities
library(viridis)         # Color palettes
library(ggpubr)          # Enhancing ggplots
library(knitr)           # Dynamic report generation

# Source custom functions
source("../R/preprocessing_functions.R") 
source("../R/differential_abundance.r") 
source("../R/visualization_functions.r") 

# Set data paths
processed_data_dir <- "../data/processed_to_ANCOM/" 
results_dir_t0_t2 <- "../results/susceptibility_T0_T2_interaction/"

# Create the new results directory if it doesn't exist
if (!dir.exists(results_dir_t0_t2)) {
  dir.create(results_dir_t0_t2, recursive = TRUE)
  message("Created results directory: ", results_dir_t0_t2)
} else {
  message("Results directory already exists: ", results_dir_t0_t2)
}
```

##2. Load Preprocessed Data
Purpose: This chunk loads the main preprocessed phyloseq object. This object, created by the preprocessing-rmd.Rmd script, contains the feature table, taxonomy, sample metadata (including pid, time, batch, cohort, case_control), and the crucial participant-level classifications for carriage_group and susceptibility_group.

```{r load-data}
# Define the name of the preprocessed phyloseq object file
# This file should have been generated by your "preprocessing-rmd.Rmd" script
# and includes the participant-level carriage_group and susceptibility_group classifications.
phyloseq_file_name <- "nm_phyloseq_classified_full.rds"
phyloseq_file_path <- file.path(processed_data_dir, phyloseq_file_name)

# Load the phyloseq object
if (file.exists(phyloseq_file_path)) {
  ps_full <- readRDS(phyloseq_file_path)
  message("Successfully loaded: ", phyloseq_file_path)
} else {
  stop("Preprocessed phyloseq file not found at: ", phyloseq_file_path,
       "\nPlease ensure the 'preprocessing-rmd.Rmd' script has been run and the file is in the correct directory.")
}

# --- Initial Checks and Summary of the Full Loaded Dataset ---

# Display basic properties of the loaded phyloseq object
print("Summary of the loaded phyloseq object (ps_full):")
print(ps_full)

# Check for presence of essential classification columns
required_cols <- c("pid", "time", "batch", "cohort", "case_control", "carriage_group", "susceptibility_group")
actual_cols <- sample_variables(ps_full)
missing_cols <- setdiff(required_cols, actual_cols)

if (length(missing_cols) > 0) {
  warning("The following required columns are missing from sample_data(ps_full): ", 
          paste(missing_cols, collapse = ", "),
          "\nThis might affect downstream analysis. Please check the preprocessing script.")
} else {
  message("All essential columns (pid, time, batch, cohort, case_control, carriage_group, susceptibility_group) are present in sample_data(ps_full).")
}

# Display distribution of participant-level carriage groups in the full dataset
# Note: These are participant-level classifications, so many samples will share the same classification if they belong to the same participant.
if ("carriage_group" %in% actual_cols) {
  message("\nDistribution of 'carriage_group' in ps_full (sample-wise):")
  print(table(sample_data(ps_full)$carriage_group, useNA = "ifany"))
}

# Display distribution of participant-level susceptibility groups
if ("susceptibility_group" %in% actual_cols) {
  message("\nDistribution of 'susceptibility_group' in ps_full (sample-wise):")
  print(table(sample_data(ps_full)$susceptibility_group, useNA = "ifany"))
  # Convert to factor if it's not already, for consistent modeling later
  if (!is.factor(sample_data(ps_full)$susceptibility_group)) {
    sample_data(ps_full)$susceptibility_group <- factor(sample_data(ps_full)$susceptibility_group)
    message("'susceptibility_group' has been converted to a factor.")
  }
}

# Display distribution of time points
if ("time" %in% actual_cols) {
  message("\nDistribution of 'time' in ps_full:")
  print(table(sample_data(ps_full)$time, useNA = "ifany"))
  # Convert to factor if it's not already, for consistent modeling later
   if (!is.factor(sample_data(ps_full)$time)) {
    sample_data(ps_full)$time <- factor(sample_data(ps_full)$time)
    message("'time' has been converted to a factor.")
  }
}

# Note: The 'susceptibility-analysis-baseline.Rmd' script also merges demographic data
# at this stage. We will handle that in a subsequent chunk if those covariates are needed.
# For now, 'ps_full' contains the core microbiome data and key study design variables.
```

##3. Define Comparison Groups and Analysis Parameters
Purpose: This chunk defines the pairs of carriage_group levels that we will iterate through for our analysis. It also sets up key parameters like the specific time points for comparison ("0" and "2") and the covariates to be included in the ANCOM-BC2 models.

```{r define-comparisons-parameters}
# 0. Define the carriage_group comparisons for iterative analysis
# These are based on the comparisons used in susceptibility-analysis-baseline.Rmd
# The analysis of susceptibility_group:time interaction will be performed *within* subsets defined by these pairs.
comparison_sets <- list(
  # Comparison 1: Focus on individuals who are either Non_carrier or Acquisition_carrier
  # This set is key for exploring factors related to initial NM acquisition.
  non_vs_acquisition = c("Non_carrier", "Acquisition_carrier"),

  # Comparison 2: Focus on individuals who are either Persistent_carrier or Non_carrier
  # This set helps compare those who consistently carry NM versus those who consistently do not.
  persistent_vs_non = c("Persistent_carrier", "Non_carrier"),

  # Comparison 3: Focus on individuals who are either Persistent_carrier or Clearance_carrier
  # This set is useful for investigating factors related to NM clearance versus persistence.
  persistent_vs_clearance = c("Persistent_carrier", "Clearance_carrier")
)

message("Defined comparison sets for iterative analysis:")
print(comparison_sets)

# 1. Define the specific time points for this analysis
time_points_to_analyze <- c("0", "2")
message("\nTime points selected for analysis: ", paste(time_points_to_analyze, collapse = " and "))

# 2. Define covariates to include in ANCOM-BC2 models
# These are based on the 'susceptibility-analysis-baseline.Rmd' (e.g., m4 formula).
# We will ensure these are present and correctly formatted in the phyloseq object
# before running ANCOM-BC2 in a later chunk.
# 'pid' will be used for random effects: (1|pid)
# 'batch' and 'cohort' are typically important.
# Demographic covariates like 'selfsmoking', 'boardingschool', 'AB_month' were used previously.

# For now, let's list the fixed effect covariates we anticipate using.
# The actual formula construction will happen during the ANCOM-BC2 modeling step.
# 'susceptibility_group' and 'time' (and their interaction) will be the primary variables of interest.
model_covariates <- c("batch", "cohort", "selfsmoking", "boardingschool", "AB_month")
message("\nCovariates planned for ANCOM-BC2 models (in addition to susceptibility_group, time, and their interaction): ",
        paste(model_covariates, collapse = ", "))
message("A random effect for 'pid' (e.g., (1|pid)) will also be considered for the ANCOM-BC2 models.")

# We will need to merge demographic data to get 'selfsmoking', 'boardingschool', 'AB_month' etc.
# This will be done in the next data preparation chunk.
```


##4. Data Preparation for Iterative Analysis (T0 vs T2)
Purpose: This chunk prepares the data for the iterative ANCOM-BC2 analysis. It involves two main steps:
1. Merging additional demographic data (covariates) into our main phyloseq object (ps_full).
2. Creating a list of phyloseq objects (ps_list_T0T2). Each element in this list will correspond to one of the comparison_sets (pairs of carriage_groups) defined previously. These phyloseq objects will be filtered to include only samples from the specified time_points_to_analyze ("0" and "2"), will have "batch 4" excluded, and will contain the necessary susceptibility_group

```{r prepare-data-for-iteration}
# --- 1. Merge Demographic Data into ps_full ---
# This step is similar to the 'load-data' chunk in susceptibility-analysis-baseline.Rmd

# Path to demographic data
# raw_data_dir is defined in preprocessing-rmd.Rmd as "../data/raw/"
# and this is where "demographic data _Jan2022_final.YM.20241230.xlsx" is expected.
demographic_file_path <- "../data/raw/demographic data _Jan2022_final.YM.20241230.xlsx"

if (file.exists(demographic_file_path)) {
  demographic_data_excel <- read_excel(demographic_file_path)
  message("Successfully loaded demographic data from: ", demographic_file_path)

  # Clean and prepare demographic data (select relevant columns and ensure correct types)
  # This matches the processing in susceptibility-analysis-baseline.Rmd
  demographic_data_to_merge <- demographic_data_excel %>%
    mutate(
      pid = as.character(pid),  # Ensure pid is character for joining
      # Ensure all model_covariates are correctly formatted
      boardingschool = factor(boardingschool),
      selfsmoking = factor(selfsmoking),
      secondsmoker = factor(secondsmoker), # Included for completeness, though not in model_covariates list for now
      AB_month = factor(AB_month),       # Antibiotic use in previous month
      AB_year = factor(AB_year)          # Antibiotic use in previous year (not in model_covariates for now)
      # Add other demographic variables if they are planned as covariates
    ) %>%
    select(pid, any_of(c("boardingschool", "selfsmoking", "secondsmoker", "AB_month", "AB_year", "yearofbirth", "family_members", model_covariates))) # Select defined covariates and pid

  # Merge with sample_data(ps_full)
  sample_data_df_full <- data.frame(sample_data(ps_full))
  
  # Preserve original rownames (SampleIDs) from ps_full
  original_ps_full_rownames <- rownames(sample_data_df_full)

  sample_data_with_demo_full <- sample_data_df_full %>%
    # Ensure pid in sample_data_df_full is character for the join
    mutate(pid = as.character(pid)) %>%
    left_join(demographic_data_to_merge, by = "pid")

  # Restore original rownames
  rownames(sample_data_with_demo_full) <- original_ps_full_rownames
  
  # Update the phyloseq object
  sample_data(ps_full) <- sample_data(sample_data_with_demo_full)
  
  message("Demographic data merged into ps_full.")
  # Verify some of the merged columns
  # message("Verification: Head of 'selfsmoking' in sample_data(ps_full):")
  # print(head(sample_data(ps_full)$selfsmoking))
  # message("Verification: Head of 'AB_month' in sample_data(ps_full):")
  # print(head(sample_data(ps_full)$AB_month))

} else {
  warning("Demographic data file not found at: ", demographic_file_path,
          "\nCovariates like 'selfsmoking', 'boardingschool', 'AB_month' will be missing. Proceeding without them.")
  # Ensure covariate columns exist as NA if file not found, so ANCOMBC doesn't fail if they are in formula
   for(covar in model_covariates){
     if(!covar %in% names(sample_data(ps_full))) {
       sample_data(ps_full)[[covar]] <- NA
     }
   }
}

# --- 2. Create a List of Phyloseq Objects for Each Comparison Set, Filtered for T0 and T2 ---
ps_list_T0T2 <- list()

for (comp_name in names(comparison_sets)) {
  current_carriage_groups <- comparison_sets[[comp_name]]
  message("\n=== Preparing phyloseq object for comparison: ", comp_name, " (", paste(current_carriage_groups, collapse = " vs "), ") ===")
  message("Filtering for time points: ", paste(time_points_to_analyze, collapse = " and "))

  # Start with a fresh copy of ps_full for each comparison set
  ps_subset <- ps_full

  # a. Filter by the two carriage_group levels for the current comparison
  # Ensure carriage_group is character for filtering, then convert to factor later
  ps_subset <- subset_samples(ps_subset, as.character(carriage_group) %in% current_carriage_groups)
  if (nsamples(ps_subset) == 0) {
    warning("No samples found for carriage groups: ", paste(current_carriage_groups, collapse = " or "), 
            " in comparison set '", comp_name, "'. Skipping this set.")
    ps_list_T0T2[[comp_name]] <- ps_subset # Store empty phyloseq object
    next
  }
  # Re-factor carriage_group to only include the two current groups, with the first as reference
  sample_data(ps_subset)$carriage_group <- factor(sample_data(ps_subset)$carriage_group, levels = current_carriage_groups)

  # b. Filter by the specified time_points_to_analyze ("0" and "2")
  # Ensure 'time' is character for robust filtering then convert to factor
  ps_subset <- subset_samples(ps_subset, as.character(time) %in% time_points_to_analyze)
  if (nsamples(ps_subset) == 0) {
    warning("No samples found for time points ", paste(time_points_to_analyze, collapse = " or "), 
            " within carriage groups '", paste(current_carriage_groups, collapse = " or "),
            "' for comparison set '", comp_name, "'. Skipping this set.")
    ps_list_T0T2[[comp_name]] <- ps_subset # Store empty phyloseq object
    next
  }
  # Ensure 'time' is a factor with correct levels for modeling
  sample_data(ps_subset)$time <- factor(sample_data(ps_subset)$time, levels = time_points_to_analyze)


  # c. Exclude "batch 4"
  # Ensure 'batch' is character for robust filtering then convert to factor
  if ("4" %in% unique(as.character(sample_data(ps_subset)$batch))) {
    ps_subset <- subset_samples(ps_subset, as.character(batch) != "4")
    message("Excluded batch '4'.")
  }
  if (nsamples(ps_subset) == 0) {
    warning("No samples remaining after excluding batch '4' for comparison set '", comp_name, "'. Skipping this set.")
    ps_list_T0T2[[comp_name]] <- ps_subset
    next
  }
  sample_data(ps_subset)$batch <- factor(sample_data(ps_subset)$batch) # Keep remaining batches as factors

  # d. Ensure susceptibility_group is a factor (should be from chunk 2, but double check)
  # This is the primary variable for interaction with time.
  if (!is.factor(sample_data(ps_subset)$susceptibility_group)) {
    sample_data(ps_subset)$susceptibility_group <- factor(sample_data(ps_subset)$susceptibility_group)
  }
  # Drop unused levels from susceptibility_group if any
  sample_data(ps_subset)$susceptibility_group <- droplevels(sample_data(ps_subset)$susceptibility_group)


  # e. Convert other relevant categorical covariates to factors and drop unused levels
  for (covar in model_covariates) {
    if (covar %in% names(sample_data(ps_subset))) {
      if (!is.factor(sample_data(ps_subset)[[covar]])) {
        sample_data(ps_subset)[[covar]] <- factor(sample_data(ps_subset)[[covar]])
      }
      sample_data(ps_subset)[[covar]] <- droplevels(sample_data(ps_subset)[[covar]])
    } else {
       # This case should be handled by the demographic data loading, but as a fallback:
      message("Covariate '", covar, "' not found in sample data for this subset. It will be NA if used in formula.")
    }
  }
  
  # f. Prune taxa with zero sums in the current subset
  if (ntaxa(ps_subset) > 0 && nsamples(ps_subset) > 0) {
      ps_subset <- prune_taxa(taxa_sums(ps_subset) > 0, ps_subset)
  }
  if (ntaxa(ps_subset) == 0 && nsamples(ps_subset) > 0) {
      warning("All taxa were removed after subsetting for comparison '", comp_name, "'. This implies all features had zero sums in this specific subset.")
  }


  # g. Sample size diagnostics for the current subset
  message("--- Diagnostics for subset: ", comp_name, " (Time ", paste(time_points_to_analyze, collapse=" & "), ") ---")
  message("Total samples in this subset: ", nsamples(ps_subset))
  
  if (nsamples(ps_subset) > 0) {
    message("Distribution by 'carriage_group' (should be the 2 groups of interest):")
    print(table(sample_data(ps_subset)$carriage_group, useNA = "ifany"))
    
    message("Distribution by 'time':")
    print(table(sample_data(ps_subset)$time, useNA = "ifany"))

    message("Distribution by 'susceptibility_group' (0=Never Case, 1=Ever Case):")
    print(table(sample_data(ps_subset)$susceptibility_group, useNA = "ifany"))
    
    # Check for at least two levels in susceptibility_group and time for interaction term
    if(length(levels(sample_data(ps_subset)$susceptibility_group)) < 2) {
      warning("Fewer than 2 levels for 'susceptibility_group' in subset '", comp_name, "'. Interaction term susceptibility_group:time cannot be estimated.")
    }
    if(length(levels(sample_data(ps_subset)$time)) < 2) {
      # This should not happen given our filtering, but good to check
      warning("Fewer than 2 levels for 'time' in subset '", comp_name, "'. Interaction term susceptibility_group:time cannot be estimated.")
    }
    
    message("Cross-tabulation of 'susceptibility_group' vs 'time':")
    print(table(Susceptibility = sample_data(ps_subset)$susceptibility_group, 
                Time = sample_data(ps_subset)$time, useNA = "ifany"))

    message("Distribution by 'batch' (after removing batch 4):")
    print(table(sample_data(ps_subset)$batch, useNA = "ifany"))

    # Check for sufficient samples per 'pid' for random effects
    # Each pid should have up to 2 samples (one for time "0", one for time "2")
    pid_counts <- table(sample_data(ps_subset)$pid)
    if(any(pid_counts > length(time_points_to_analyze))){
        warning("Some PIDs have more samples than expected time points in subset '", comp_name, "'. Check data for duplicates.")
    }
    # message("Number of samples per PID (should be <= ", length(time_points_to_analyze), "):")
    # print(summary(as.vector(pid_counts)))
    # if (any(pid_counts < 2)) {
    #   message("Note: Some PIDs in subset '", comp_name, "' have only one time point (either T0 or T2, but not both). ",
    #           "ANCOM-BC2 with random effects for 'pid' will still run, but these PIDs won't contribute to estimating within-subject change.")
    # }
  } else {
    message("No samples in this subset to perform diagnostics.")
  }
  
  # h. Store the prepared phyloseq object
  ps_list_T0T2[[comp_name]] <- ps_subset
  message("--- Finished preparing subset: ", comp_name, " ---")
}

# Summary of created list
message("\nSuccessfully created 'ps_list_T0T2' with ", length(ps_list_T0T2), " phyloseq objects.")
# print(names(ps_list_T0T2))
# Optional: Check nsamples in each created phyloseq object
# for (comp_name in names(ps_list_T0T2)) {
#   message("Samples in ps_list_T0T2[['", comp_name, "']]: ", nsamples(ps_list_T0T2[[comp_name]]))
# }
```


## 5. Differential Abundance Analysis with ANCOM-BC2 (T0 vs T2 Interaction)
Purpose: This chunk performs the differential abundance testing using ANCOM-BC2. It iterates through each prepared phyloseq object in ps_list_T0T2 (each corresponding to a carriage_group comparison pair). For each object, it runs ANCOM-BC2 to identify taxa that show a significant interaction effect between susceptibility_group and time (Time 0 vs. Time 2),

```{r run-ancombc2-t0-t2}
# Initialize a list to store ANCOM-BC2 results for each comparison set
ancom_results_T0T2 <- list()

# Define parameters for ANCOM-BC2 consistent with baseline analysis
tax_level_to_analyze <- "Genus"
prevalence_cutoff <- 0.10 # Used in run_ancombc2_models in baseline script
random_effects_formula <- "(1|pid)" # To account for repeated measures

# Loop over each prepared phyloseq object in ps_list_T0T2
for (comp_name in names(ps_list_T0T2)) {
  message("\n=== Running ANCOM-BC2 for comparison set: ", comp_name, " ===")
  ps_subset <- ps_list_T0T2[[comp_name]]

  # Check if the phyloseq subset is empty or has too few samples/taxa
  if (is.null(ps_subset) || nsamples(ps_subset) < 10 || ntaxa(ps_subset) == 0) { # Min samples threshold is arbitrary, adjust if needed
    message("Skipping ANCOM-BC2 for '", comp_name, "' due to insufficient samples (", nsamples(ps_subset), ") or taxa (", ntaxa(ps_subset), ").")
    ancom_results_T0T2[[comp_name]] <- list(error = paste("Insufficient samples or taxa for", comp_name))
    next
  }
  
  # Check for at least two levels in susceptibility_group and time for interaction term
  # These checks were also done during subset creation, but good to re-verify here.
  current_sample_data <- data.frame(sample_data(ps_subset))
  if (length(unique(current_sample_data$susceptibility_group)) < 2 || 
      length(unique(current_sample_data$time)) < 2) {
    message("Skipping ANCOM-BC2 for '", comp_name, 
            "' as 'susceptibility_group' or 'time' has fewer than 2 levels in this subset. Interaction cannot be estimated.")
    ancom_results_T0T2[[comp_name]] <- list(error = paste("Fewer than 2 levels in susceptibility_group or time for", comp_name))
    next
  }

  # Dynamically build the fixed effects formula string
  # Start with the main interaction effect
  formula_terms <- c("susceptibility_group * time") # susceptibility_group + time + susceptibility_group:time
  
  # Add other covariates, checking if they have enough variation in the current subset
  valid_covariates <- c()
  for (covar in model_covariates) {
    if (covar %in% names(current_sample_data)) {
      # Check if the covariate has more than one level and is not all NA
      if (length(unique(current_sample_data[[covar]][!is.na(current_sample_data[[covar]])])) > 1) {
        valid_covariates <- c(valid_covariates, covar)
      } else {
        message("Covariate '", covar, "' excluded for '", comp_name, "' due to having only one level or all NA values in this subset.")
      }
    }
  }
  if (length(valid_covariates) > 0) {
    formula_terms <- c(formula_terms, valid_covariates)
  }
  
  fixed_effects_formula <- paste(formula_terms, collapse = " + ")
  message("Using fixed effects formula for '", comp_name, "': ", fixed_effects_formula)
  message("Using random effects formula for '", comp_name, "': ", random_effects_formula)

  # Run ANCOM-BC2 using the custom wrapper function
  # The 'group_var' in run_ancombc2 is the main variable for pairwise comparisons.
  # For an interaction model, we are primarily interested in the significance of the interaction term itself.
  # We'll set group_var to "susceptibility_group", and then examine the interaction term results.
  # The run_ancombc2 function has pairwise=TRUE hardcoded.
  
  current_ancom_result <- tryCatch({
    run_ancombc2(
      ps_object = ps_subset,
      tax_level = tax_level_to_analyze,
      formula_str = fixed_effects_formula,
      group_var = "susceptibility_group", # Main group for LFC direction, interaction term is key output
      prv_cut = prevalence_cutoff,
      rand_formula = random_effects_formula, # Pass the random effects formula
      seed = 123
      # Other parameters for run_ancombc2 are set to its defaults
      # (p_adj_method = "holm", pseudo_sens = TRUE, lib_cut = 1000, struc_zero = TRUE, etc.)
    )
  }, error = function(e) {
    message("Error running ANCOM-BC2 for '", comp_name, "': ", e$message)
    return(list(error = e$message, formula = fixed_effects_formula, rand_formula = random_effects_formula))
  })
  
  ancom_results_T0T2[[comp_name]] <- current_ancom_result
  if (is.null(current_ancom_result$error)) {
     message("Successfully ran ANCOM-BC2 for comparison set: ", comp_name)
  }
}

# Save the ANCOM-BC2 results
ancom_rds_file_t0_t2 <- file.path(results_dir_t0_t2, "ancombc2_results_T0T2_interaction.rds")
saveRDS(ancom_results_T0T2, file = ancom_rds_file_t0_t2)
message("\nANCOM-BC2 results for T0-T2 interaction saved to: ", ancom_rds_file_t0_t2)

# --- Brief Summary of Results (Focus on Interaction Term) ---
message("\n--- Summary of ANCOM-BC2 Interaction Term Significance (susceptibility_group:time) ---")
for (comp_name in names(ancom_results_T0T2)) {
  result <- ancom_results_T0T2[[comp_name]]
  if (!is.null(result$error)) {
    message(comp_name, ": Error during ANCOM-BC2 execution - ", result$error)
    next
  }
  if (is.null(result$res) || nrow(result$res) == 0) {
    message(comp_name, ": No results found in ANCOM-BC2 output.")
    next
  }
  
  # ANCOM-BC2 names interaction terms like: diff_variable1LEVEL1variable2LEVEL2 or diff_variable1variable2
  # For susceptibility_group (0,1) and time (0,2), it might be "diff_susceptibility_group1:time2" if that's how levels are encoded,
  # or a more general interaction column. We need to find the correct column name.
  # Let's look for columns containing "susceptibility_group" and "time" and "diff_"
  res_df <- result$res
  interaction_col_pattern <- "diff_susceptibility_group.*:time.*|diff_time.*:susceptibility_group.*" # Flexible pattern
  
  diff_cols <- colnames(res_df)
  interaction_col_name <- grep(interaction_col_pattern, diff_cols, value = TRUE)
  
  # Fallback: ANCOM-BC2 for "A*B" might list the interaction diff column as "diff_A:B" or similar structure
  # Let's assume standard naming might be related to levels, e.g. susceptibility_group1:time2
  # For a binary susceptibility_group (0,1) and time (0,2), and ref level 0 for both,
  # interaction term often refers to (susceptibility_group1 - susceptibility_group0) at time2 vs (susceptibility_group1 - susceptibility_group0) at time0
  # A common interaction column name might be 'diff_susceptibility_group1.time1' (if time levels are 0 and 1 internally)
  # or more generally, ANCOMBC objects often include a general interaction column.
  # Let's search for a column with both variable names.
  
  possible_interaction_cols <- character(0)
  if (any(grepl("susceptibility_group", diff_cols) & grepl("time", diff_cols) & grepl(":", diff_cols))) {
      possible_interaction_cols <- diff_cols[grepl("susceptibility_group", diff_cols) & grepl("time", diff_cols) & grepl(":", diff_cols)]
  }

  if (length(possible_interaction_cols) > 0) {
    # Assuming the first match is the one we care about, or there's only one.
    # If there are multiple (e.g. susceptibility_group0:time2, susceptibility_group1:time2), you may need to be more specific
    # For a 2x2 interaction, there's typically one main interaction test column.
    chosen_interaction_col <- possible_interaction_cols[1] 
    num_sig_interaction <- sum(res_df[[chosen_interaction_col]] == TRUE, na.rm = TRUE)
    message(comp_name, ": ", num_sig_interaction, " taxa showed significant interaction (", chosen_interaction_col, ") at alpha = 0.05 (Holm adjusted).")
    
    # If sensitivity scores (passed_ss_) are available for the interaction term, we can also report that
    ss_interaction_col <- gsub("diff_", "passed_ss_", chosen_interaction_col)
    if (ss_interaction_col %in% colnames(res_df)) {
        num_sig_interaction_ss <- sum(res_df[[chosen_interaction_col]] == TRUE & res_df[[ss_interaction_col]] == TRUE, na.rm = TRUE)
        message("  Of which, ", num_sig_interaction_ss, " also passed the sensitivity score for interaction.")
    }
    
  } else {
    message(comp_name, ": Could not automatically identify a clear 'susceptibility_group:time' interaction diff column in results. Please inspect results manually. Available diff columns: ", paste(grep("^diff_", colnames(res_df), value=T), collapse=", "))
  }
}
```