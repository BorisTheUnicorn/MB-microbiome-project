ancombc2_vis$sig_taxa[[comparison]],
file = file.path(results_dir, paste0("sig_taxa_", comparison, ".csv")),
row.names = FALSE
)
}
}
# Create a heatmap of significant taxa abundances
create_abundance_heatmap <- function(ps_obj, sig_taxa_names, group_var) {
# Check if we have significant taxa
if(length(sig_taxa_names) == 0) {
return(NULL)
}
# Subset to significant taxa
ps_subset <- prune_taxa(sig_taxa_names, ps_obj)
# Transform to relative abundance
ps_rel <- transform_sample_counts(ps_subset, function(x) x / sum(x))
# Extract abundance data
abund_mat <- as(otu_table(ps_rel), "matrix")
if(taxa_are_rows(ps_rel)) {
abund_mat <- t(abund_mat)
}
# Get sample metadata
sample_meta <- data.frame(sample_data(ps_rel))
group_data <- sample_meta[[group_var]]
# Create a data frame for ggplot
abund_df <- as.data.frame(abund_mat)
abund_df$SampleID <- rownames(abund_df)
abund_df$Group <- group_data
# Reshape to long format
abund_long <- abund_df %>%
pivot_longer(cols = -c(SampleID, Group),
names_to = "Taxon",
values_to = "Abundance")
# Create heatmap
heatmap_plot <- ggplot(abund_long, aes(x = SampleID, y = Taxon, fill = Abundance)) +
geom_tile() +
facet_grid(. ~ Group, scales = "free_x", space = "free_x") +
scale_fill_viridis_c(name = "Relative\nAbundance") +
labs(title = paste("Abundance of Significant Taxa by", group_var),
x = "Sample", y = "Taxon") +
theme_minimal() +
theme(axis.text.x = element_blank(),
axis.ticks.x = element_blank())
return(heatmap_plot)
}
# Extract significant taxa across all comparisons
all_sig_taxa <- unique(unlist(lapply(ancombc2_vis$sig_taxa, function(x) x$taxon)))
# Create and display heatmap if we have significant taxa
if(length(all_sig_taxa) > 0) {
heatmap_plot <- create_abundance_heatmap(ps_suscept, all_sig_taxa, "susceptibility_group")
if(!is.null(heatmap_plot)) {
print(heatmap_plot)
ggsave(file.path(results_dir, "susceptibility_sig_taxa_heatmap.png"),
heatmap_plot, width = 12, height = 8)
}
}
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6
)
# Load required packages
library(phyloseq)
library(ANCOMBC)
library(dplyr)
library(ggplot2)
library(tidyr)
library(readxl)
library(DT)
library(patchwork)
library(microbiome)
library(viridis)
# Source custom functions
source("../R/preprocessing_functions.R")
source("../R/differential_abundance.r")
source("../R/visualization_functions.r")
# Set data paths
processed_data_dir <- "../data/processed/"
results_dir <- "../results/original_susceptibility/"
# Create results directory if it doesn't exist
if(!dir.exists(results_dir)) {
dir.create(results_dir, recursive = TRUE)
}
library(vegan)
library(ggpubr)
library(microbiome)
library(phyloseq)
library(qiime2R)
library(microeco)
library(dplyr)
library(tidyverse)
library(magrittr)
library(sva)
library(GUniFrac)
getwd()
setwd("C:/Users/nikop/Desktop/אוניברסיטה/מחקר מודרך/orrrr/project/data/raw")
# Import data
metadata <- read_q2metadata("00.metadata.combined.2020_2021.tsv")
taxa <- read_qza("taxonomy-dada2.qza")$data %>% parse_taxonomy()
feature_table <- as.data.frame(read_qza("table-dada2.qza")$data)
tree <- read_qza("rooted-tree-dada2.qza")$data
setwd("C:/Users/nikop/Desktop/אוניברסיטה/מחקר מודרך/orrrr/project/scripts")
View(feature_table)
dim(feature_table)
View(metadata)
View(taxa)
# Prepare the microeco dataset
rownames(metadata) <- metadata[,1]  # Set sample IDs as rownames
dataset <- microtable$new(sample_table = metadata,
otu_table = feature_table,
tax_table = taxa,
phylo_tree = tree)
View(tree)
View(dataset)
# Basic data tidying
dataset$tidy_dataset()
dataset$tax_table %<>% base::subset(Kingdom == "Archaea" | Kingdom == "Bacteria")
dataset$filter_pollution(taxa = c("mitochondria", "chloroplast"))
dataset$rarefy_samples(sample.size = 5000, method = "rarefy")  # Rarefying to 5000 reads per sample
# Calculate beta diversity
dataset$cal_betadiv(unifrac = TRUE)
dataset$beta_diversity
dataset$beta_diversity$jaccard
# Function for beta ordination
create_beta_ordination <- function(dataset,
factor_name,
measure = "bray",
method = "PCoA",
plot_type = c("point", "ellipse"),
title = NULL,
color_values = NULL) {
# Create the trans_beta object
beta_obj <- trans_beta$new(dataset = dataset,
group = factor_name,
measure = measure)
# Run the ordination
beta_obj$cal_ordination(method = method)
# Generate the plot title if not provided
if(is.null(title)) {
title <- paste("Beta Diversity by", factor_name)
}
# Create the plot
beta_plot <- beta_obj$plot_ordination(
plot_type = plot_type,
plot_color = factor_name,
plot_shape = factor_name,
) +
labs(title = title)
# Return both the object and the plot
return(list(
beta_object = beta_obj,
plot = beta_plot
))
}
# Create ordination for year
year_results <- create_beta_ordination(
dataset = dataset,
factor_name = "year",
title = "Pre-correction - Batch Effect by Year"
)
year_results$plot
year_results$beta_object
# Create ordination for carriage status
carriage_results <- create_beta_ordination(
dataset = dataset,
factor_name = "case_control",
title = "Pre-correction - Samples by NM Carriage Status"
)
carriage_results$plot
# Extract the abundance matrix
abundance_matrix <- dataset$otu_table
View(abundance_matrix)
feature_table_colnames <- colnames(feature_table)
meta_data_filter_feature <- metadata %>% filter(SampleID %in% feature_table_colnames)
View(meta_data_filter_feature)
feature_table_colnames2 <- feature_table_colnames2[1:50]
feature_table_colnames2 <- feature_table_colnames[1:50]
meta_data_filter_feature <- metadata %>% filter(SampleID %in% feature_table_colnames2)
meta_data_filter_feature <- metadata %>% filter(SampleID %in% feature_table_colnames)
abundance_matrix_colnames <- colnames(abundance_matrix)
meta_data_filter_abundance <- metadata %>% filter(SampleID %in% abundance_matrix_colnames)
View(meta_data_filter_abundance)
print(colnames(meta_data_filter_feature) not %in% colnames(meta_data_filter_abundance))
print(colnames(meta_data_filter_feature) %in% colnames(meta_data_filter_abundance))
colnames(meta_data_filter_abundance)
filtered_samples <- anti_join(meta_data_filter_feature,meta_data_filter_abundance,by = "SampleID")
view(filtered_samples)
view(feature_table$1364-4_S228)
view(feature_table$`1364-4_S228`)
sum(feature_table$`1364-4_S228`)
sum(feature_table$`1025-0_S164`)
sum(feature_table$`1016-4_S185`)
view(feature_table$`1016-4_S185`)
sum(feature_table$`1016-4_S185` != 0)
sum(feature_table$`1364-4_S228` != 0)
sum(feature_table$`1025-0_S164` != 0)
sum(abundance_matrix$`1024-2_S80` != 0)
sum(feature_table$`1024-2_S80` != 0)
# Create ordination for batch
batch_results <- create_beta_ordination(
dataset = dataset,
factor_name = "batch",
title = "Pre-correction - Batch Effect by Sequencing Batch"
)
batch_results$plot
# Create ordination for time point
time_results <- create_beta_ordination(
dataset = dataset,
factor_name = "time",
title = "Pre-correction - Samples by Time Point"
)
time_results$plot
# Create ordination for carriage status
carriage_results <- create_beta_ordination(
dataset = dataset,
factor_name = "case_control",
title = "Pre-correction - Samples by NM Carriage Status"
)
# Extract the abundance matrix
abundance_matrix <- dataset$otu_table
# Get the batch information
batch <- dataset$sample_table$year  # Using year as the batch variable (can be changed to 'batch' if needed)
view(batch)
# Make sure the data is in the right format for ComBat
# ComBat expects samples as columns, features as rows, but our data might be transposed
if(nrow(abundance_matrix) > ncol(abundance_matrix)) {
# If we have more rows than columns, the data is likely already in the right format
# (features as rows, samples as columns)
abundance_matrix_for_combat <- abundance_matrix
} else {
# If we have more columns than rows, transpose
abundance_matrix_for_combat <- t(abundance_matrix)
}
# Apply CLR transformation
# Add pseudocount to handle zeros
abundance_matrix_for_combat[abundance_matrix_for_combat == 0] <- 0.5
clr_abundance <- log2(abundance_matrix_for_combat)  # Simple log2 transform for ComBat
# Run ComBat - ensure batch is a factor
batch_factor <- as.factor(batch)
corrected_abundance <- ComBat(dat = clr_abundance,
batch = batch_factor,
mod = NULL,
par.prior = TRUE)
View(filtered_samples)
# Extract the abundance matrix
abundance_matrix <- dataset$otu_table
# Get the batch information
batch <- dataset$sample_table$year  # Using year as the batch variable (can be changed to 'batch' if needed)
# Make sure the data is in the right format for ComBat
# ComBat expects samples as columns, features as rows, but our data might be transposed
if(nrow(abundance_matrix) > ncol(abundance_matrix)) {
# If we have more rows than columns, the data is likely already in the right format
# (features as rows, samples as columns)
abundance_matrix_for_combat <- abundance_matrix
} else {
# If we have more columns than rows, transpose
abundance_matrix_for_combat <- t(abundance_matrix)
}
# Apply CLR transformation
# Add pseudocount to handle zeros
abundance_matrix_for_combat[abundance_matrix_for_combat == 0] <- 0.5
clr_abundance <- log2(abundance_matrix_for_combat)  # Simple log2 transform for ComBat
# Run ComBat - ensure batch is a factor
batch_factor <- as.factor(batch)
corrected_abundance <- ComBat(dat = clr_abundance,
batch = batch_factor,
mod = NULL,
par.prior = TRUE)
# Convert back from log2
corrected_counts <- 2^corrected_abundance
# Handle any negative values
corrected_counts[corrected_counts < 0] <- 0
# Ensure the corrected data is in the right format for the dataset object
if(nrow(abundance_matrix) > ncol(abundance_matrix)) {
# If the original data had features as rows, no need to transpose back
final_corrected_counts <- corrected_counts
} else {
# If we transposed earlier, transpose back
final_corrected_counts <- t(corrected_counts)
}
# Create a new dataset with corrected abundances
dataset_corrected <- dataset$clone()
dataset_corrected$otu_table <- final_corrected_counts
# Calculate beta diversity for the corrected dataset
dataset_corrected$cal_betadiv(unifrac = TRUE)
# Create post-correction ordinations using the same function
year_results_corrected <- create_beta_ordination(
dataset = dataset_corrected,
factor_name = "year",
title = "Post-correction - Batch Effect by Year"
)
batch_results_corrected <- create_beta_ordination(
dataset = dataset_corrected,
factor_name = "batch",
title = "Post-correction - Batch Effect by Sequencing Batch"
)
time_results_corrected <- create_beta_ordination(
dataset = dataset_corrected,
factor_name = "time",
title = "Post-correction - Samples by Time Point"
)
carriage_results_corrected <- create_beta_ordination(
dataset = dataset_corrected,
factor_name = "case_control",
title = "Post-correction - Samples by NM Carriage Status"
)
# Visualize all pre- and post-correction plots
# Install patchwork if not already installed
if (!requireNamespace("patchwork", quietly = TRUE)) {
install.packages("patchwork")
}
library(patchwork)
# Compare pre- vs post-correction for each factor
year_comparison <- year_results$plot + year_results_corrected$plot
batch_comparison <- batch_results$plot + batch_results_corrected$plot
time_comparison <- time_results$plot + time_results_corrected$plot
carriage_comparison <- carriage_results$plot + carriage_results_corrected$plot
# Display the comparisons
year_comparison
batch_comparison
time_comparison
carriage_comparison
knitr::opts_chunk$set(
echo = TRUE,
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6
)
# Load required packages
library(vegan)
library(microbiome)
library(phyloseq)
library(qiime2R)
library(microeco)
library(dplyr)
library(tidyverse)
library(magrittr)
library(sva)
library(GUniFrac)
library(ggplot2)
library(patchwork)
# Source custom functions
source("../R/preprocessing_functions.R")
source("../R/visualization_functions.r")
# Set data paths
raw_data_dir <- "../data/raw/"
processed_data_dir <- "../data/processed/"
# Create processed directory if it doesn't exist
if(!dir.exists(processed_data_dir)) {
dir.create(processed_data_dir, recursive = TRUE)
}
# Import QIIME2 data using our custom function
dataset <- import_qiime2_data(
metadata_path = file.path(raw_data_dir, "00.metadata.combined.2020_2021.tsv"),
feature_table_path = file.path(raw_data_dir, "table-dada2.qza"),
taxonomy_path = file.path(raw_data_dir, "taxonomy-dada2.qza"),
tree_path = file.path(raw_data_dir, "rooted-tree-dada2.qza")
)
# Import QIIME2 data using our custom function
dataset <- import_qiime2_data(
metadata_path = file.path(raw_data_dir, "00.metadata.combined.2020_2021.tsv"),
feature_table_path = file.path(raw_data_dir, "table-dada2.qza"),
taxonomy_path = file.path(raw_data_dir, "taxonomy-dada2.qza"),
tree_path = file.path(raw_data_dir, "rooted-tree-dada2.qza")
)
# Basic dataset summary
print(dataset)
# Sample count per time point
table(dataset$sample_table$time)
# Sample count per case/control status
table(dataset$sample_table$case_control)
# Sample count per year
table(dataset$sample_table$year)
# Sample count per batch
table(dataset$sample_table$batch)
# Check for specific issues with batch 4
batch4_samples <- dataset$sample_table[dataset$sample_table$batch == 4, ]
print(paste("Number of samples in batch 4:", nrow(batch4_samples)))
if(nrow(batch4_samples) > 0) {
print(batch4_samples)
}
nrow(batch4_samples)
print(batch4_samples)
View(batch4_samples)
# Calculate basic taxonomic composition
tax_summary <- dataset$tax_table %>%
as.data.frame() %>%
group_by(Phylum) %>%
summarise(count = n()) %>%
arrange(desc(count))
# Display top 10 phyla
head(tax_summary, 10)
tax_summary
View(tax_summary)
# Calculate beta diversity
dataset$cal_betadiv(unifrac = TRUE)
# Create ordination plots for potential batch effects and biological factors
# Using the simplified plot_pcoa function
year_plot <- plot_pcoa(
dataset = dataset,
factor_name = "year",
title = "Samples by Year"
)
batch_plot <- plot_pcoa(
dataset = dataset,
factor_name = "batch",
title = "Samples by Sequencing Batch"
)
time_plot <- plot_pcoa(
dataset = dataset,
factor_name = "time",
title = "Samples by Time Point"
)
carriage_plot <- plot_pcoa(
dataset = dataset,
factor_name = "case_control",
title = "Samples by NM Carriage Status"
)
# Display the plots
year_plot
batch_plot
time_plot
carriage_plot
# Calculate beta diversity
dataset$cal_betadiv(unifrac = TRUE)
# Create ordination plots for potential batch effects and biological factors
# Using the simplified plot_pcoa function
year_plot <- plot_pcoa(
dataset = dataset,
factor_name = "year",
title = "Samples by Year"
)
# Display the plots
year_plot
# Calculate beta diversity
dataset$cal_betadiv(measure = "bray")
# Calculate beta diversity
dataset$cal_betadiv(measure = "bray")
# Create ordination plots for potential batch effects and biological factors
# Using the simplified plot_pcoa function
year_plot <- plot_pcoa(
dataset = dataset,
factor_name = "year",
title = "Samples by Year"
)
# Display the plots
year_plot
# Calculate beta diversity
dataset$cal_betadiv(unifrac = TRUE)
# Create ordination plots for potential batch effects and biological factors
# Using the simplified plot_pcoa function
year_plot <- plot_pcoa(
dataset = dataset,
factor_name = "year",
title = "Samples by Year"
)
batch_plot <- plot_pcoa(
dataset = dataset,
factor_name = "batch",
title = "Samples by Sequencing Batch"
)
time_plot <- plot_pcoa(
dataset = dataset,
factor_name = "time",
title = "Samples by Time Point"
)
carriage_plot <- plot_pcoa(
dataset = dataset,
factor_name = "case_control",
title = "Samples by NM Carriage Status"
)
# Display the plots
year_plot
batch_plot
time_plot
carriage_plot
# Calculate beta diversity
dataset$cal_betadiv(unifrac = TRUE)
# Clone the original dataset for comparison
dataset_original <- dataset$clone()
# Apply batch correction using the custom function
# Using year as the batch variable
dataset_corrected <- correct_batch_effect(
dataset = dataset,
batch_var = "year",
method = "simple_log",
round_counts = TRUE
)
# Calculate beta diversity for the corrected dataset
dataset_corrected$cal_betadiv(unifrac = TRUE)
# Create comparison plots using the simplified function
comparison_plots <- compare_correction_plots(
dataset_original = dataset_original,
dataset_corrected = dataset_corrected,
factor_names = c("year", "batch", "time", "case_control"),
plot_titles = c(
"Batch Effect by Year",
"Batch Effect by Sequencing Batch",
"Samples by Time Point",
"Samples by NM Carriage Status"
)
)
# Display the comparison plots
comparison_plots$year
comparison_plots$batch
comparison_plots$time
comparison_plots$case_control
# Update our dataset to use the corrected one
dataset <- dataset_corrected
